/*/////////////////////////////////////////////////////////////////////////////
/// @summary Implement wrappers around the functions and macros generated by 
/// the message compiler from the instrumentation manifest XML. These functions
/// form the public interface to the profiler.
///////////////////////////////////////////////////////////////////////////80*/

/*////////////////////
//   Preprocessor   //
////////////////////*/

/*///////////////
//   Globals   //
///////////////*/

/*////////////////////////
//   Public Functions   //
////////////////////////*/
/// @summary Initialize the profiler and register basic application properties.
/// @param config An object describing the application to the profiler.
/// @return One of PROFILER_RESULT specifying whether the profiler was successfully initialized.
int32_t __cdecl
InitializeProfiler
(
    PROFILER_CONFIG *config
)
{   
    if (config == NULL || config->ApplicationName == NULL)
    {   // the application must identify itself to the profiler.
        return PROFILER_RESULT_INVALID_APPINFO;
    }
    if (config->ProfilerMajorVersion > PROFILER_VERSION_MAJOR || config->ProfilerMajorVersion == 0)
    {   // the application is requesting a newer profiler version than is supported.
        return PROFILER_RESULT_INVALID_VERSION;
    }

    LARGE_INTEGER       qpc = {};
    uint64_t      frequency = 0;
    DWORD        process_id = GetProcessId(GetCurrentProcess());

    // retrieve the frequency of the system high-resolution timer.
    QueryPerformanceFrequency(&qpc);
    frequency = uint64_t(qpc.QuadPart);

    // call the registration functions, which are defined in the generated provider.h file.
    EventRegisterProfiler_Task();

    // emit the process registration event to the trace log.
    EventWriteRegisterProfiledProcessEvent(
        process_id, 
        config->ApplicationName, 
        config->ApplicationMajorVersion, 
        config->ApplicationMinorVersion, 
        config->ComputePoolSize, 
        config->GeneralPoolSize, 
        frequency);

    return PROFILER_RESULT_SUCCESS;
}

/// @summary Shutdown the profiler prior to application shutdown.
void __cdecl 
ShutdownProfiler
(
    void
)
{   // unregister the custom ETW provider(s).
    EventUnregisterProfiler_Task();
}

/// @summary Register information about a worker thread with the profiler.
/// @param thread_id The operating system identifier of the worker thread.
/// @param pool The application identifier of the thread pool.
/// @param pool_index The zero-based index of the worker thread within the pool.
void __cdecl 
RegisterWorkerThread
(
    uint32_t  thread_id,
    uint32_t       pool, 
    uint32_t pool_index
)
{
    EventWriteRegisterWorkerThreadEvent(thread_id, pool, pool_index);
}

/// @summary Register information about a thread that can produce tasks with the profiler.
/// @param source_name A NULL-terminated ANSI string identifying the source thread.
/// @param owning_thread_id The operating system identifier of the task producer thread.
/// @param source_index The zero-based index of the task source within the scheduler.
void __cdecl
RegisterTaskSource
(
    char const   *source_name, 
    uint32_t owning_thread_id,
    uint32_t     source_index
)
{
    EventWriteRegisterTaskSourceEvent(source_name, owning_thread_id, source_index);
}

/// @summary Mark the point in time at which a task is defined.
/// @param task_id The identifier of the new task.
/// @param parent_id The identifier of the parent task, or INVALID_TASK_ID.
/// @param task_main The entry point of the task.
/// @param source_index The zero-based index of the task source within the scheduler.
/// @param dependency_count The number of tasks that must complete before the new task can run.
/// @param dependencies The list of task identifiers that must complete before the new task can run, or NULL.
void __cdecl
MarkTaskDefinition
(
    uint32_t             task_id, 
    uint32_t           parent_id, 
    void              *task_main, 
    uint32_t        source_index, 
    uint32_t    dependency_count,
    uint32_t const *dependencies
)
{
    uint32_t dep_list[3] = {
        INVALID_TASK_ID, 
        INVALID_TASK_ID, 
        INVALID_TASK_ID
    };
    if (dependencies != NULL && dependency_count > 0)
    {
        for (size_t i = 0, n  = dependency_count > 3 ? 3 : dependency_count; i < n; ++i)
        {
            dep_list[i] = dependencies[i];
        }
    }
    EventWriteDefineTaskEvent(task_id, parent_id, task_main, source_index, dep_list[0], dep_list[1], dep_list[2]);
}

/// @summary Mark the point in time at which a task becomes ready-to-run.
/// @param task_id The identifier of the task that is now ready-to-run.
/// @param source_index The zero-based index of the task source within the scheduler that's responsible for the state transition.
void __cdecl
MarkTaskReadyToRun
(
    uint32_t      task_id, 
    uint32_t source_index
)
{
    EventWriteTaskReadyToRunEvent(task_id, source_index);
}

/// @summary Mark the point in time at which a worker thread begins executing a task.
/// @param task_id The identifier of the task that is being launched.
void __cdecl
MarkTaskLaunch
(
    uint32_t task_id
)
{
    EventWriteTaskLaunchEvent(task_id, GetCurrentThreadId());
}

/// @summary Mark the point in time at which a worker thread finishes executing a task.
/// @param task_id The identifier of the task that is being launched.
void __cdecl
MarkTaskFinish
(
    uint32_t task_id
)
{
    EventWriteTaskFinishEvent(task_id, GetCurrentThreadId());
}

